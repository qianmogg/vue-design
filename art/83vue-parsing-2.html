<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue技术内幕 | 句法分析 - 生成真正的AST(二)</title>
    <meta name="description" content="逐行级别的 Vue 源码分析">
    <script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <link rel="preload" href="/vue-design/assets/css/0.styles.efeaeef6.css" as="style"><link rel="preload" href="/vue-design/assets/js/app.b12bc3e2.js" as="script"><link rel="preload" href="/vue-design/assets/js/10.a388adda.js" as="script"><link rel="prefetch" href="/vue-design/assets/js/16.cefe293b.js"><link rel="prefetch" href="/vue-design/assets/js/1.6d05dcd4.js"><link rel="prefetch" href="/vue-design/assets/js/2.aac14d68.js"><link rel="prefetch" href="/vue-design/assets/js/3.e504159e.js"><link rel="prefetch" href="/vue-design/assets/js/4.5535cd4f.js"><link rel="prefetch" href="/vue-design/assets/js/5.6297331b.js"><link rel="prefetch" href="/vue-design/assets/js/6.01be8f8a.js"><link rel="prefetch" href="/vue-design/assets/js/7.d26e3f4d.js"><link rel="prefetch" href="/vue-design/assets/js/8.0efd6021.js"><link rel="prefetch" href="/vue-design/assets/js/9.50adfb3b.js"><link rel="prefetch" href="/vue-design/assets/js/11.8b01d048.js"><link rel="prefetch" href="/vue-design/assets/js/12.c184b139.js"><link rel="prefetch" href="/vue-design/assets/js/13.ff5e875c.js"><link rel="prefetch" href="/vue-design/assets/js/14.1b89e814.js"><link rel="prefetch" href="/vue-design/assets/js/15.f64ae162.js"><link rel="prefetch" href="/vue-design/assets/js/17.371b21c7.js"><link rel="prefetch" href="/vue-design/assets/js/18.1d291304.js"><link rel="prefetch" href="/vue-design/assets/js/19.bfd489ff.js"><link rel="prefetch" href="/vue-design/assets/js/20.0df215af.js"><link rel="prefetch" href="/vue-design/assets/js/21.8f0e1847.js"><link rel="prefetch" href="/vue-design/assets/js/22.04046067.js"><link rel="prefetch" href="/vue-design/assets/js/23.aa250bf5.js"><link rel="prefetch" href="/vue-design/assets/js/24.8de96ffd.js"><link rel="prefetch" href="/vue-design/assets/js/25.9e6bf3b5.js"><link rel="prefetch" href="/vue-design/assets/js/26.48ec0614.js"><link rel="prefetch" href="/vue-design/assets/js/27.7324200f.js"><link rel="prefetch" href="/vue-design/assets/js/28.41e12abe.js"><link rel="prefetch" href="/vue-design/assets/js/29.d0b48134.js"><link rel="prefetch" href="/vue-design/assets/js/30.8b28f1c1.js"><link rel="prefetch" href="/vue-design/assets/js/31.1b9f4981.js"><link rel="prefetch" href="/vue-design/assets/js/32.10efce5b.js">
    <link rel="stylesheet" href="/vue-design/assets/css/0.styles.efeaeef6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/vue-design/" class="home-link router-link-active"><!----><span class="site-name">
      Vue技术内幕
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-design/art/" class="nav-link router-link-active">正文</a></div><div class="nav-item"><a href="/vue-design/appendix/" class="nav-link">附录</a></div><div class="nav-item"><a href="/vue-design/more/" class="nav-link">扩展阅读</a></div><div class="nav-item"><a href="/vue-design/donate/" class="nav-link">人之初</a></div><div class="nav-item"><a href="/vue-design/about/" class="nav-link">关于</a></div><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-design/art/" class="nav-link router-link-active">正文</a></div><div class="nav-item"><a href="/vue-design/appendix/" class="nav-link">附录</a></div><div class="nav-item"><a href="/vue-design/more/" class="nav-link">扩展阅读</a></div><div class="nav-item"><a href="/vue-design/donate/" class="nav-link">人之初</a></div><div class="nav-item"><a href="/vue-design/about/" class="nav-link">关于</a></div><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><div><ins data-ad-client="ca-pub-4613560834313397" data-ad-slot="2465217753" class="adsbygoogle" style="display:block;box-sizing:border-box;width:100%;height:120px;margin:10px auto 0;"></ins></div><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>正文(持续更新...)</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/vue-design/art/" class="sidebar-link">写在前面</a></li><li><a href="/vue-design/art/1start-learn.html" class="sidebar-link">了解 Vue 这个项目</a></li><li><a href="/vue-design/art/2vue-constructor.html" class="sidebar-link">Vue 构造函数</a></li><li><a href="/vue-design/art/3vue-example.html" class="sidebar-link">以一个例子为线索</a></li><li><a href="/vue-design/art/4vue-normalize.html" class="sidebar-link">Vue 选项的规范化</a></li><li><a href="/vue-design/art/5vue-merge.html" class="sidebar-link">Vue 选项的合并</a></li><li><a href="/vue-design/art/6vue-init-start.html" class="sidebar-link">Vue 的初始化之开篇</a></li><li><a href="/vue-design/art/7vue-reactive.html" class="sidebar-link">揭开数据响应系统的面纱</a></li><li><a href="/vue-design/art/8vue-reactive-dep-watch.html" class="sidebar-link">渲染函数的观察者与进阶的数据响应系统</a></li><li><a href="/vue-design/art/9vue-state-init.html" class="sidebar-link">其他重要选项的初始化及实现</a></li><li><a href="/vue-design/art/80vue-compiler-start.html" class="sidebar-link">Vue 的编译器初探</a></li><li><a href="/vue-design/art/81vue-lexical-analysis.html" class="sidebar-link">词法分析 - 为生成AST做准备</a></li><li><a href="/vue-design/art/82vue-parsing.html" class="sidebar-link">句法分析 - 生成真正的AST(一)</a></li><li><a href="/vue-design/art/83vue-parsing-2.html" class="active sidebar-link">句法分析 - 生成真正的AST(二)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#彻底理解解析属性值的方式" class="sidebar-link">彻底理解解析属性值的方式</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#processattrs-处理剩余属性" class="sidebar-link">processAttrs 处理剩余属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#解析-v-bind-指令" class="sidebar-link">解析 v-bind 指令</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#解析-v-on-指令" class="sidebar-link">解析 v-on 指令</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#解析其他指令" class="sidebar-link">解析其他指令</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#处理非指令属性" class="sidebar-link">处理非指令属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#文本节点的元素描述对象" class="sidebar-link">文本节点的元素描述对象</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#parsetext-函数解析字面量表达式" class="sidebar-link">parseText 函数解析字面量表达式</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#对结束标签的处理" class="sidebar-link">对结束标签的处理</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#注释节点的元素描述对象" class="sidebar-link">注释节点的元素描述对象</a></li><li class="sidebar-sub-header"><a href="/vue-design/art/83vue-parsing-2.html#对元素描述对象的总结" class="sidebar-link">对元素描述对象的总结</a></li></ul></li><li><a href="/vue-design/art/84vue-codegen.html" class="sidebar-link">编译器之代码的生成</a></li><li><a href="/vue-design/art/85vue-vdom.html" class="sidebar-link">虚拟DOM解析</a></li><li><a href="/vue-design/art/86vue-vdom-patch.html" class="sidebar-link">虚拟DOM补丁算法详解</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="句法分析-生成真正的ast-二"><a href="#句法分析-生成真正的ast-二" aria-hidden="true" class="header-anchor">#</a> 句法分析 - 生成真正的AST(二)</h1><p>鉴于篇幅的原因，本章将继承上一章的内容，继续讲解 <code>AST</code> 的生成。</p><h2 id="彻底理解解析属性值的方式"><a href="#彻底理解解析属性值的方式" aria-hidden="true" class="header-anchor">#</a> 彻底理解解析属性值的方式</h2><p>接下来我们要讲解的就是 <code>processElement</code> 函数中调用的最后一个 <code>process*</code> 函数，它就是 <code>processAttrs</code> 函数，这个函数是用来处理元素描述对象的 <code>el.attrsList</code> 数组中剩余的所有属性的。到目前为止我们已经讲解过的属性有：</p><ul><li><code>v-pre</code></li><li><code>v-for</code></li><li><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code></li><li><code>v-once</code></li><li><code>key</code></li><li><code>ref</code></li><li><code>slot</code>、<code>slot-scope</code>、<code>scope</code>、<code>name</code></li><li><code>is</code>、<code>inline-template</code></li></ul><p>以上这些属性的解析我们已经全部讲解过了，我们能够发现一些规律，比如在获取这些属性的值的时候，要么使用 <code>getAndRemoveAttr</code> 函数，要么就使用 <code>getBindingAttr</code> 函数，但是无论使用哪个函数，其共同的行为是：<strong>在获取到特定属性值的同时，还会将该属性从 <code>el.attrsList</code> 数组中移除</strong>。所以在调用 <code>processAttrs</code> 函数的时候，以上列出来的属性都已经从 <code>el.attrsList</code> 数组中移除了。但是 <code>el.attrsList</code> 数组中仍然可能存在其他属性，所以这个时候就需要使用 <code>processAttrs</code> 函数处理 <code>el.attrsList</code> 数组中剩余的属性。</p><p>在讲解 <code>processAttrs</code> 函数之前，我们来回顾一下现在我们掌握的知识。以如上列出的属性为例，下表中总结了特定的属性与获取该属性值的方式：</p><table><thead><tr><th>属性</th><th>获取属性值的方式</th></tr></thead><tbody><tr><td><code>v-pre</code></td><td><code>getAndRemoveAttr</code></td></tr><tr><td><code>v-for</code></td><td><code>getAndRemoveAttr</code></td></tr><tr><td><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code></td><td><code>getAndRemoveAttr</code></td></tr><tr><td><code>v-once</code></td><td><code>getAndRemoveAttr</code></td></tr><tr><td><code>key</code></td><td><code>getBindingAttr</code></td></tr><tr><td><code>ref</code></td><td><code>getBindingAttr</code></td></tr><tr><td><code>name</code></td><td><code>getBindingAttr</code></td></tr><tr><td><code>slot-scope</code>、<code>scope</code></td><td><code>getAndRemoveAttr</code></td></tr><tr><td><code>slot</code></td><td><code>getBindingAttr</code></td></tr><tr><td><code>is</code></td><td><code>getBindingAttr</code></td></tr><tr><td><code>inline-template</code></td><td><code>getAndRemoveAttr</code></td></tr></tbody></table><p>我们发现凡是以 <code>v-</code> 开头的属性，在获取属性值的时候都是通过 <code>getAndRemoveAttr</code> 函数获取的。而对于没有 <code>v-</code> 开头的特性，如 <code>key</code>、<code>ref</code> 等，在获取这些属性的值时，是通过 <code>getBindingAttr</code> 函数获取的，不过 <code>slot-scope</code>、<code>scope</code> 和 <code>inline-template</code> 这三个属性虽然没有以 <code>v-</code> 开头，但仍然使用 <code>getAndRemoveAttr</code> 函数获取其属性值。但这并不是关键，关键的是我们要知道使用 <code>getAndRemoveAttr</code> 和 <code>getBindingAttr</code> 这两个函数获取属性值的时候到底有什么区别。</p><p>我们知道类似于 <code>v-for</code> 或 <code>v-if</code> 这类以 <code>v-</code> 开头的属性，在 <code>Vue</code> 中我们称之为指令，并且这些属性的属性值是默认情况下被当做表达式处理的，比如：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>a &amp;&amp; b<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上代码在执行的时候 <code>a</code> 和 <code>b</code> 都会被当做变量，并且 <code>a &amp;&amp; b</code> 是具有完整意义的表达式，而非普通字符串。并且在解析阶段，如上 <code>div</code> 标签的元素描述对象的 <code>el.attrsList</code> 属性将是如下数组：</p><pre class="language-js"><code>el<span class="token punctuation">.</span>attrsList <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'v-if'</span><span class="token punctuation">,</span>
    value<span class="token punctuation">:</span> <span class="token string">'a &amp;&amp; b'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre><p>这时，当使用 <code>getAndRemoveAttr</code> 函数获取 <code>v-if</code> 属性值时，得到的就是字符串 <code>'a &amp;&amp; b'</code>，但不要忘了这个字符串最终是要运行在 <code>new Function()</code> 函数中的，假设是如下代码：</p><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'a &amp;&amp; b'</span><span class="token punctuation">)</span>
</code></pre><p>那么这句代码等价于：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">&amp;&amp;</span> b
<span class="token punctuation">}</span>
</code></pre><p>可以看到，此时的 <code>a &amp;&amp; b</code> 已经不再是普通字符串了，而是表达式。</p><p>这就意味着 <code>slot-scope</code>、<code>scope</code> 和 <code>inline-template</code> 这三个属性的值，最终也将会被作为表达式处理，而非普通字符串。如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>slotProps<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上代码是使用作用域插槽的典型例子，我们知道这里的 <code>slotProps</code> 确实是变量，而非字符串。</p><p>那如果使用 <code>getBindingAttr</code> 函数获取 <code>slot-scope</code> 属性的值会产生什么效果呢？由于 <code>slot-scope</code> 没有并非 <code>v-bind:slot-scope</code> 或 <code>:slot-scope</code>，所以在使用 <code>getBindingAttr</code> 函数获取 <code>slot-scope</code> 属性值的时候，将会得到使用 <code>JSON.stringify</code> 函数处理后的结果，即：</p><pre class="language-js"><code><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'slotProps'</span><span class="token punctuation">)</span>
</code></pre><p>这个值就是字符串 <code>'&quot;slotProps&quot;'</code>，我们把这个字符串拿到 <code>new Function()</code> 中，如下：</p><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'&quot;slotProps&quot;'</span><span class="token punctuation">)</span>
</code></pre><p>如上这句代码等价于：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;slotProps&quot;</span>
<span class="token punctuation">}</span>
</code></pre><p>可以发现此时函数体内只有一个字符串 <code>&quot;slotProps&quot;</code>，而非变量。</p><p>但并不是说使用了 <code>getBindingAttr</code> 函数获取的属性值最终都是字符串，如果该属性是绑定的属性(使用 <code>v-bind</code> 或 <code>:</code>)，则该属性的值仍然具有 <code>javascript</code> 语言的能力。否则该属性的值就是一个普通的字符串。</p><h2 id="processattrs-处理剩余属性"><a href="#processattrs-处理剩余属性" aria-hidden="true" class="header-anchor">#</a> processAttrs 处理剩余属性</h2><p><code>processAttrs</code> 函数是 <code>processElement</code> 函数中调用的最后一个 <code>process*</code> 函数，在这之前已经调用了很多其他的 <code>process*</code> 函数对元素进行了处理，并且每当处理一个属性时，都会将该属性从元素描述对象的 <code>el.attrsList</code> 数组中移除，但 <code>el.attrsList</code> 数组中仍然保存着剩余未被处理的属性，而 <code>processAttrs</code> 函数就是用来处理这些剩余属性的。</p><p>既然 <code>processAttrs</code> 函数用来处理剩余未被处理的属性，那么我们首先要确定的是 <code>el.attrsList</code> 数组中都包含哪些剩余的属性，如下是前面已经处理过的属性：</p><ul><li><code>v-pre</code></li><li><code>v-for</code></li><li><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code></li><li><code>v-once</code></li><li><code>key</code></li><li><code>ref</code></li><li><code>slot</code>、<code>slot-scope</code>、<code>scope</code>、<code>name</code></li><li><code>is</code>、<code>inline-template</code></li></ul><p>如上属性中包含了部分 <code>Vue</code> 内置的指令(<code>v-</code> 开头的属性)，大家可以对照一下 <code>Vue</code> 的官方文档，查看其内置的指令，可以发现之前的讲解中不包含对以下指令的解析：</p><ul><li><code>v-text</code>、<code>v-html</code>、<code>v-show</code>、<code>v-on</code>、<code>v-bind</code>、<code>v-model</code>、<code>v-cloak</code></li></ul><p>除了这些指令之外，还有部分属性的处理我们也没讲到，比如 <code>class</code> 属性和 <code>style</code> 属性，这两个属性比较特殊，因为 <code>Vue</code> 对他们做了增强，实际上在“中置处理”(<code>transforms</code> 数组)中有有对于 <code>class</code> 属性和 <code>style</code> 属性的处理，这个我们后面会统一讲解。</p><p>再有就是一些普通属性的处理了，如下 <code>html</code> 代码所示：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:custom-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>someVal<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@custom-event</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleEvent<span class="token punctuation">&quot;</span></span> <span class="token attr-name">other-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>static-prop<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上代码所示，其中 <code>:custom-prop</code> 是自定义的绑定属性，<code>@custom-event</code> 是自定义的事件，<code>other-prop</code> 是自定义的非绑定的属性，对于这些内容的处理都是由 <code>processAttrs</code> 函数完成的。其实处理自定义绑定属性本质上就是处理 <code>v-bind</code> 指令，而处理自定义事件就是处理 <code>v-on</code> 指令。</p><p>接下来我们具体查看一下 <code>processAttrs</code> 函数的源码，看看它是如何处理这些剩余未被处理的指令的。如下是简化后的代码：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">processAttrs</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> el<span class="token punctuation">.</span>attrsList
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> l<span class="token punctuation">,</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> isProp
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>可以看到在 <code>processAttrs</code> 函数内部，首先定义了 <code>list</code> 常量，它是 <code>el.attrsList</code> 数组的引用。接着有定义了一些列变量待使用，然后开启了一个 <code>for</code> 循环，循环的目的就是遍历 <code>el.attrsList</code> 数组，所以我们能够想到在循环内部就是逐个处理 <code>el.attrsList</code> 数组中那些剩余的属性的。</p><p><code>for</code> 循环内部的代码被一个 <code>if...else</code> 语句块分成两部分，如下：</p><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> rawName <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name
  value <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value
  <span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在 <code>if...else</code> 语句块之前，分别为 <code>name</code>、<code>rawName</code> 以及 <code>value</code> 变量赋了值，其中 <code>name</code> 和 <code>rawName</code> 变量中保存的是属性的名字，而 <code>value</code> 变量中则保存着属性的值。然后才执行了 <code>if...else</code> 语句块，我们来看一下 <code>if</code> 条件语句的判断条件：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>使用 <code>dirRe</code> 正则去匹配属性名 <code>name</code>，<code>dirRE</code> 正则我们前面讲过了，它用来匹配一个字符串是否以 <code>v-</code>、<code>@</code> 或 <code>:</code> 开头，所以如果匹配成功则说明该属性是指令，此时 <code>if</code> 语句块内的代码会被执行，否则将执行 <code>else</code> 语句块的代码。举个例子，如下 <code>html</code> 片段所示：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:custom-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>someVal<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@custom-event</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleEvent<span class="token punctuation">&quot;</span></span> <span class="token attr-name">other-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>static-prop<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>其中 <code>:custom-prop</code> 属性和 <code>@custom-event</code> 属性将会被 <code>if</code> 语句块内的代码处理，而对于 <code>other-prop</code> 属性则会被 <code>else</code> 语句块内的代码处理。</p><p>接下来我们优先看一下如果该属性是一个指令，那么在 <code>if</code> 语句块内是如何对该指令进行处理的，如下代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// mark element as dynamic</span>
  el<span class="token punctuation">.</span>hasBindings <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// modifiers</span>
  modifiers <span class="token operator">=</span> <span class="token function">parseModifiers</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span></span>    <span class="token comment">// 省略...</span>
<span class="highlighted-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span></span>    <span class="token comment">// 省略...</span>
<span class="highlighted-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span></span>    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>如果代码执行到了这里，我们能够确认的是该属性是一个指令，如上高亮的三句代码所示，这是一个 <code>if...elseif...else</code> 语句块，不难发现 <code>if</code> 语句的判断条件是在检测该指令是否是 <code>v-bind</code>(包括缩写 <code>:</code>) 指令，<code>elseif</code> 语句的判断条件是在检测该指令是否是 <code>v-on</code>(包括缩写 <code>@</code>) 指令，而对于其他指令则会执行 <code>else</code> 语句块的代码。后面我们会对这三个分支内的代码做详细讲解，不过在这之前我们再来看一下如下高亮的代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// mark element as dynamic</span>
<span class="highlighted-line">  el<span class="token punctuation">.</span>hasBindings <span class="token operator">=</span> <span class="token boolean">true</span></span>  <span class="token comment">// modifiers</span>
<span class="highlighted-line">  modifiers <span class="token operator">=</span> <span class="token function">parseModifiers</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>一个完整的指令包含指令的名称、指令的参数、指令的修饰符以及指令的值，以上高亮代码的作用是用来解析指令中的修饰符的。首先既然元素使用了指令，那么该指令的值就是表达式，既然是表达式那就涉及动态的内容，所以此时会在元素描述对象上添加 <code>el.hasBindings</code> 属性，并将其值设置为 <code>true</code>，标识着当前元素是一个动态的元素。接着执行了如下这句代码：</p><pre class="language-js"><code>modifiers <span class="token operator">=</span> <span class="token function">parseModifiers</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
</code></pre><p>调用 <code>parseModifiers</code> 函数，该函数接收整个指令字符串作为参数，作用就是解析指令中的修饰符，并将解析结果赋值给 <code>modifiers</code> 变量。我们找到 <code>parseModifiers</code> 函数的代码，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parseModifiers</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> match <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    match<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>m <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> ret<span class="token punctuation">[</span>m<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在 <code>parseModifiers</code> 函数内部首先使用指令字符串的 <code>match</code> 方法匹配正则 <code>modifierRE</code>，<code>modifierRE</code> 正则我们在上一章讲过，它用来全局匹配字符串中字符 <code>.</code> 以及 <code>.</code> 后面的字符，也就是修饰符，举个例子，假设我们的指令字符串为：<code>'v-bind:some-prop.sync'</code>，则使用该字符串去匹配正则 <code>modifierRE</code> 最终将会得到一个数组：<code>[&quot;.sync&quot;]</code>。一个指令有几个修饰符，则匹配的结果数组中就包含几个元素。如果匹配失败则会得到 <code>null</code>。回到上面的代码，定义了 <code>match</code> 常量，它保存着匹配结果。接着是一个 <code>if</code> 语句块，如果匹配成功则会执行 <code>if</code> 语句块内的代码，在 <code>if</code> 语句块内首先定义了 <code>ret</code> 常量，它是一个空对象，并且我们发现 <code>ret</code> 常量将作为匹配成功时的返回结果，<code>ret</code> 常量是什么呢？来看这句代码：</p><pre class="language-js"><code>match<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>m <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> ret<span class="token punctuation">[</span>m<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>使用 <code>forEach</code> 循环遍历了 <code>match</code> 数组，然后将每一项都作为 <code>ret</code> 对象的属性，并将其值设置为 <code>true</code>。注意由于 <code>match</code> 数组中的每个修饰符中都包含了字符 <code>.</code>，所以如上代码中使用 <code>m.slice(1)</code> 将字符 <code>.</code> 去掉。假设我们的指令字符串为：<code>'v-bind:some-prop.sync'</code>，则最终 <code>parseModifiers</code> 会返回一个对象：</p><pre class="language-js"><code><span class="token punctuation">{</span>
  sync<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><p>当然了，如果指令字符串中不包含修饰符，则 <code>parseModifiers</code> 函数没有返回值，或者说其返回值为 <code>undefined</code>。</p><p>再回到如下这段代码，注意高亮的代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// mark element as dynamic</span>
  el<span class="token punctuation">.</span>hasBindings <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// modifiers</span>
<span class="highlighted-line">  modifiers <span class="token operator">=</span> <span class="token function">parseModifiers</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>在使用 <code>parseModifiers</code> 函数解析完指令中的修饰符之后，会使用 <code>modifiers</code> 变量保存解析结果，如果解析成功，将会执行如下代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>这句代码的作用很简单，就是讲修饰符从指令字符串中移除，也就是说此时的指令字符串 <code>name</code> 中已经不包含修饰符部分了。</p><h3 id="解析-v-bind-指令"><a href="#解析-v-bind-指令" aria-hidden="true" class="header-anchor">#</a> 解析 v-bind 指令</h3><p>处理完了修饰符，将进入对于指令的解析，解析环节分为三部分，分别是对于 <code>v-bind</code> 指令的解析，对于 <code>v-on</code> 指令的解析，以及对于其他指令的解析。如下代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// mark element as dynamic</span>
  el<span class="token punctuation">.</span>hasBindings <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// modifiers</span>
  modifiers <span class="token operator">=</span> <span class="token function">parseModifiers</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>modifierRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span></span>    <span class="token comment">// 省略...</span>
<span class="highlighted-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span></span>    <span class="token comment">// 省略...</span>
<span class="highlighted-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span></span>    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮的代码所示，该 <code>if...elseif...else</code> 语句块分别用来处理 <code>v-bind</code> 指令、<code>v-on</code> 指令以及其他指令。我们先来看 <code>if</code> 语句块：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>该 <code>if</code> 语句的判断条件是使用 <code>bindRE</code> 去匹配指令字符串，如果一个指令以 <code>v-bind:</code> 或 <code>:</code> 开头，则说明该指令为 <code>v-bind</code> 指令，这时 <code>if</code> 语句块内的代码将被执行，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
<span class="highlighted-line">  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>bindRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  value <span class="token operator">=</span> <span class="token function">parseFilters</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></span><span class="highlighted-line">  isProp <span class="token operator">=</span> <span class="token boolean">false</span></span>  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>首先使用 <code>bindRE</code> 正则将指令字符串中的 <code>v-bind:</code> 或 <code>:</code> 去除掉，此时 <code>name</code> 字符串已经从一个完成的指令字符串变为绑定属性的名字了，举个例子，假如原本的指令字符串为 <code>'v-bind:some-prop.sync'</code>，由于之前已经把该字符串中修饰符的部分取出掉了，所以指令字符串将变为 <code>'v-bind:some-prop'</code>，接着如上第一句高亮的代码又将指令字符串中的 <code>v-bind:</code> 去掉，所以此时指令字符串将变为 <code>'some-prop'</code>，可以发现该字符串就是绑定属性的名字，或者说是 <code>v-bind</code> 指令的参数。</p><p>接着调用 <code>parseFilters</code> 函数处理绑定属性的值，我们知道 <code>parseFilters</code> 函数的作用是用来将表达式与过滤器整合在一起的，前面我们已经做了详细的讲解，但凡涉及到能够使用过滤器的地方都要使用 <code>parseFilters</code> 函数去解析，并将解析后的新表达式返回。如上第二句高亮的代码所示，使用 <code>parseFilters</code> 函数的返回值重新赋值 <code>value</code> 变量。</p><p>第三句高亮的代码将 <code>isProp</code> 变量初始化为 <code>false</code>，<code>isProp</code> 变量标识着该绑定的属性是否是原生DOM对象属性，所谓原生DOM对象的属性就是能够通过DOM元素对象直接访问的有效API，比如 <code>innerHTML</code> 就是一个原生DOM对象属性。</p><p>再往下将进入一段 <code>if</code> 条件语句，该 <code>if</code> 语句块的作用是用来处理修饰符的：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>    isProp <span class="token operator">=</span> <span class="token boolean">true</span>
    name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">'innerHtml'</span><span class="token punctuation">)</span> name <span class="token operator">=</span> <span class="token string">'innerHTML'</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>camel<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>    name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>    <span class="token function">addHandler</span><span class="token punctuation">(</span>
      el<span class="token punctuation">,</span>
      <span class="token template-string"><span class="token string">`update:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>
      <span class="token function">genAssignmentCode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`$event`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>当然了，如果没有给 <code>v-bind</code> 属性提供修饰符，则这段 <code>if</code> 语句的代码将被忽略。<code>v-bind</code> 属性为开发者提供了三个修饰符，分别是 <code>prop</code>、<code>camel</code> 和 <code>sync</code>，这恰好对应如上代码中的三段 <code>if</code> 语句块。我们先来看第一段 <code>if</code> 语句块：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isProp <span class="token operator">=</span> <span class="token boolean">true</span>
  name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">'innerHtml'</span><span class="token punctuation">)</span> name <span class="token operator">=</span> <span class="token string">'innerHTML'</span>
<span class="token punctuation">}</span>
</code></pre><p>这段 <code>if</code> 语句块的代码用来处理使用了 <code>prop</code> 修饰符的 <code>v-bind</code> 指令，既然使用了 <code>prop</code> 修饰符，则意味着该属性将被作为原生DOM对象的属性，所以首先会将 <code>isProp</code> 变量设置为 <code>true</code>，接着使用 <code>camelize</code> 函数将属性名驼峰化，最后还会检查驼峰化之后的属性名是否等于字符串 <code>'innerHtml'</code>，如果属性名全等于该字符串则将属性名重写为字符串 <code>'innerHTML'</code>，我们知道 <code>'innerHTML'</code> 是一个特例，它的 <code>HTML</code> 四个字符串全部为大写。以上就是对于使用了 <code>prop</code> 修饰符的 <code>v-bind</code> 指令的处理，如果一个绑定属性使用了 <code>prop</code> 修饰符则 <code>isProp</code> 变量会被设置为 <code>true</code>，并且会把属性名字驼峰化。那么为什么要将 <code>isProp</code> 变量设置为 <code>true</code> 呢？答案在如下代码中：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>bindRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  value <span class="token operator">=</span> <span class="token function">parseFilters</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  isProp <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isProp <span class="token operator">=</span> <span class="token boolean">true</span>
      name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">'innerHtml'</span><span class="token punctuation">)</span> name <span class="token operator">=</span> <span class="token string">'innerHTML'</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>isProp <span class="token operator">||</span> <span class="token punctuation">(</span></span>    <span class="token operator">!</span>el<span class="token punctuation">.</span>component <span class="token operator">&amp;&amp;</span> <span class="token function">platformMustUseProp</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> el<span class="token punctuation">.</span>attrsMap<span class="token punctuation">.</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">addProp</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">addAttr</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮的代码所示，如果 <code>isProp</code> 为真则会执行该 <code>if</code> 语句块内的代码，即调用 <code>addProp</code> 函数，而 <code>else</code> 语句块内的 <code>addAttr</code> 函数是永远不会被调用的。我们前面讲解过 <code>addAttr</code> 函数，它会将属性的名字和值以对象的形式添加到元素描述对象的 <code>el.attrs</code> 数组中，<code>addProp</code> 函数与 <code>addAttr</code> 函数类似，只不过 <code>addProp</code> 函数会把属性的名字和值以对象的形式添加到元素描述对象的 <code>el.props</code> 数组中。如下是 <code>addProp</code> 函数的源码，它来自 <code>src/compiler/helpers.js</code> 文件：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addProp</span> <span class="token punctuation">(</span>el<span class="token punctuation">:</span> ASTElement<span class="token punctuation">,</span> name<span class="token punctuation">:</span> string<span class="token punctuation">,</span> value<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>el<span class="token punctuation">.</span>props <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>props <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span>
  el<span class="token punctuation">.</span>plain <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre><p>总之 <code>isProp</code> 变量是一个重要的标识，它的值将会影响一个属性被添加到元素描述对象的位置，从而影响后续的行为。另外这里在啰嗦一句：<strong>元素描述对象的 <code>el.props</code> 数组中存储的并不是组件概念中的 <code>prop</code>，而是原生DOM对象的属性</strong>。在后面的章节中我们会看到，组件概念中的 <code>prop</code> 其实是在 <code>el.attrs</code> 数组中。</p><p>有点扯远了，我们回过头来，明白了 <code>prop</code> 修饰符和 <code>isProp</code> 变量的作用之后，我们再来看一下对于 <code>camel</code> 修饰符的处理，如下代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>camel<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    name <span class="token operator">=</span> <span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮的代码所示，如果 <code>modifiers.camel</code> 为真，则说明该绑定的属性使用了 <code>camel</code> 修饰符，使用该修饰符的作用只有一个，那就是将绑定的属性驼峰化，如下代码如实：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">:view-box.camel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewBox<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>有的同学可能会说，我直接写成驼峰不就可以了吗：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">:viewBox</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewBox<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>不行，这是因为对于浏览器来讲，真正的属性名字是 <code>:viewBox</code> 而不是 <code>viewBox</code>，所以浏览器在渲染时会认为这是一个自定义属性，对于任何自定义属性浏览器都会把它渲染为小写的形式，所以当 <code>Vue</code> 尝试获取这段模板字符串的时候，会得到如下字符串：</p><pre class="language-js"><code><span class="token string">'&lt;svg :viewbox=&quot;viewBox&quot;&gt;&lt;/svg&gt;'</span>
</code></pre><p>最终渲染的真实DOM将是：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">viewbox</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewBox<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>这将导致渲染失败，因为 <code>SVG</code> 标签只认 <code>viewBox</code>，却不知道 <code>viewbox</code> 是什么。</p><p>可能大家已经注意到了，这个问题仅存在于 <code>Vue</code> 需要获取被浏览器处理后的模板字符串时才会出现，所以如果你使用了 <code>template</code> 选项代替 <code>Vue</code> 自动读取则不会出现这个问题：</p><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;svg :viewBox=&quot;viewBox&quot;&gt;&lt;/svg&gt;'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>当然了，使用单文件组件也不会出现这种问题，所以这些情况下我们是不需要使用 <code>camel</code> 修饰符的。</p><p>接着我们来看一下对于最后一个修饰符的处理，即 <code>sync</code> 修饰符：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>camel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    <span class="token function">addHandler</span><span class="token punctuation">(</span></span><span class="highlighted-line">      el<span class="token punctuation">,</span></span><span class="highlighted-line">      <span class="token template-string"><span class="token string">`update:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span></span><span class="highlighted-line">      <span class="token function">genAssignmentCode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`$event`</span></span><span class="token punctuation">)</span></span><span class="highlighted-line">    <span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span>
</code></pre><p>如上高亮代码所示，如果 <code>modifiers.sync</code> 为真，则说明该绑定的属性使用了 <code>sync</code> 修饰符。<code>sync</code> 修饰符实际上是一个语法糖，子组件不能够直接修改 <code>prop</code> 值，通常我们会在子组件中发射一个自定义事件，然后在父组件层面监听该事件并由父组件来修改状态。这个过程有时候过于繁琐，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:some-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@custom-event</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleEvent<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token string">''</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleEvent</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>为了简化该过程，我们可以在绑定属性时使用 <code>sync</code> 修饰符：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:some-prop.sync</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><p>这句代码等价于：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:some-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>someProp</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleEvent<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token string">''</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleEvent</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>注意事件名称 <code>update:someProp</code> 是固定的，它由 <code>update:</code> 加上驼峰化的绑定属性名称组成。所以在子组件中你需要发射一个名字叫做 <code>update:someProp</code> 的事件才能使 <code>sync</code> 修饰符生效，不难看出这大大提高了开发者的开发效率。</p><p>在 <code>Vue</code> 内部，使用 <code>sync</code> 修饰符的绑定属性与没有使用 <code>sync</code> 修饰符的绑定属性之间差异就在于：使用了 <code>sync</code> 修饰符的绑定属性等价于多了一个事件侦听，并且事件名称为 <code>'update:${驼峰化的属性名}'</code>。我们回到源码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>camel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
  <span class="token punctuation">}</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    <span class="token function">addHandler</span><span class="token punctuation">(</span></span><span class="highlighted-line">      el<span class="token punctuation">,</span></span><span class="highlighted-line">      <span class="token template-string"><span class="token string">`update:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span></span><span class="highlighted-line">      <span class="token function">genAssignmentCode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`$event`</span></span><span class="token punctuation">)</span></span><span class="highlighted-line">    <span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span>
</code></pre><p>可以看到如果发现该绑定的属性使用了 <code>sync</code> 修饰符，则直接调用 <code>addHandler</code> 函数，在当前元素描述对象上添加事件侦听器。<code>addHandler</code> 函数的作用实际上就是将事件名称与该事件的侦听函数添加到元素描述对象的 <code>el.events</code> 属性或 <code>el.nativeEvents</code> 属性中。对于 <code>addHandler</code> 函数的实现我们将会在即将讲解的 <code>v-on</code> 指令的解析中为大家详细说明。这里大家要关注的是一个公式：</p><pre class="language-js"><code><span class="token punctuation">:</span>some<span class="token operator">-</span>prop<span class="token punctuation">.</span>sync <span class="token operator">&lt;=</span><span class="token operator">=</span>等价于<span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">:</span>some<span class="token operator">-</span>prop <span class="token operator">+</span> @update<span class="token punctuation">:</span>someProp
</code></pre><p>通过如下代码我们就能够知道事件名称的构成：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">addHandler</span><span class="token punctuation">(</span>
    el<span class="token punctuation">,</span>
<span class="highlighted-line">    <span class="token template-string"><span class="token string">`update:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">camelize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span></span>    <span class="token function">genAssignmentCode</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`$event`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮到吗所示，事件名称等于字符串 <code>'update:'</code> 加上驼峰化的绑定属性名称。另外我们注意到传递给 <code>addHandler</code> 函数的第三个参数，实际上 <code>addHandler</code> 函数的第三个参数就是当事件发生时的回调函数，而该回调函数是通过 <code>genAssignmentCode</code> 函数生成的。<code>genAssignmentCode</code> 函数来自 <code>src/compiler/directives/model.js</code> 文件，如下是其源码：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">genAssignmentCode</span> <span class="token punctuation">(</span>
  value<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  assignment<span class="token punctuation">:</span> string
<span class="token punctuation">)</span><span class="token punctuation">:</span> string <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">parseModel</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>assignment<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`$set(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>res<span class="token punctuation">.</span>exp<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>res<span class="token punctuation">.</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>assignment<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>要讲解 <code>genAssignmentCode</code> 函数将会牵扯很多东西，实际上 <code>genAssignmentCode</code> 函数也被用在 <code>v-model</code> 指令，因为本质上 <code>v-model</code> 指令与绑定属性加上 <code>sync</code> 修饰符几乎相同，所以我们会在讲解 <code>v-model</code> 指令时再来详细讲解 <code>genAssignmentCode</code> 函数。这里大家只要关注一下如上代码中 <code>genAssignmentCode</code> 的返回值即可，它返回的是一个代码字符串，可以看到如果这个代码字符串作为代码执行，其作用就是一个赋值工作。这样就免去了我们手工赋值的繁琐。</p><p>以上我们讲完了对于三个绑定属性可以使用的修饰符，接下来我们来看处理绑定属性的最后一段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>isProp <span class="token operator">||</span> <span class="token punctuation">(</span>
  <span class="token operator">!</span>el<span class="token punctuation">.</span>component <span class="token operator">&amp;&amp;</span> <span class="token function">platformMustUseProp</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> el<span class="token punctuation">.</span>attrsMap<span class="token punctuation">.</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">addProp</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">addAttr</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>实际上这段代码我们已经简单过了，这里要强调的是 <code>if</code> 语句的判断条件：</p><pre class="language-js"><code>isProp <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">.</span>component <span class="token operator">&amp;&amp;</span> <span class="token function">platformMustUseProp</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> el<span class="token punctuation">.</span>attrsMap<span class="token punctuation">.</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>前面说过了如果 <code>isProp</code> 变量为真，则说明该绑定的属性是原生DOM对象的属性，但是如果 <code>isProp</code> 变量为假，那么就要看第二个条件是否成立，如果第二个条件成立，则该绑定的属性还是会作为原生DOM对象的属性，第二个条件如下：</p><pre class="language-js"><code><span class="token operator">!</span>el<span class="token punctuation">.</span>component <span class="token operator">&amp;&amp;</span> <span class="token function">platformMustUseProp</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> el<span class="token punctuation">.</span>attrsMap<span class="token punctuation">.</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
</code></pre><p>首先 <code>el.component</code> 必须为假，这个条件能够保证什么呢？我们知道 <code>el.component</code> 属性保存的是标签 <code>is</code> 属性的值，如果 <code>el.component</code> 属性为假就能够保证标签没有使用 <code>is</code> 属性。那么为什么需要这个保证呢？这是因为后边的 <a href="/vue-design/appendix/web-util.html#mustuseprop">platformMustUseProp</a> 函数，该函数的讲解可以在附录中查看，总结如下：</p><ul><li><code>input,textarea,option,select,progress</code> 这些标签的 <code>value</code> 属性都应该使用元素对象的原生的 <code>prop</code> 绑定（除了 <code>type === 'button'</code> 之外）</li><li><code>option</code> 标签的 <code>selected</code> 属性应该使用元素对象的原生的 <code>prop</code> 绑定</li><li><code>input</code> 标签的 <code>checked</code> 属性应该使用元素对象的原生的 <code>prop</code> 绑定</li><li><code>video</code> 标签的 <code>muted</code> 属性应该使用元素对象的原生的 <code>prop</code> 绑定</li></ul><p>可以看到如果满足这些条件，则意味着即使你在绑定以上属性时没有使用 <code>prop</code> 修饰符，那么它们依然会被当做原生DOM对象的属性。不过我们还是没有解释为什么要保证 <code>!el.component</code> 成立，这是因为 <code>platformMustUseProp</code> 函数在判断的时候需要标签的名字(<code>el.tag</code>)，而 <code>el.component</code> 会在元素渲染阶段替换掉 <code>el.tag</code> 的值。所以如果 <code>el.component</code> 存在则会影响 <code>platformMustUseProp</code> 的判断结果。</p><p>最后我们来对 <code>v-bind</code> 指令的解析做一个总结：</p><ul><li>1、任何绑定的属性，最终要么会被添加到元素描述对象的 <code>el.attrs</code> 数组中，要么就被添加到元素描述对象的 <code>el.props</code> 数组中。</li><li>2、对于使用了 <code>.sync</code> 修饰符的绑定属性，还会在元素描述对象的 <code>el.events</code> 对象中添加名字为 <code>'update:${驼峰化的属性名}'</code> 的事件。</li></ul><h3 id="解析-v-on-指令"><a href="#解析-v-on-指令" aria-hidden="true" class="header-anchor">#</a> 解析 v-on 指令</h3><p>接下来我们来看一下 <code>processAttrs</code> 函数对于 <code>v-on</code> 指令的解析，如下代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
<span class="highlighted-line">  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>onRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token function">addHandler</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> warn<span class="token punctuation">)</span></span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>与 <code>v-bind</code> 指令类似，使用 <code>onRE</code> 正则去匹配指令字符串，如果该指令字符串以 <code>@</code> 或 <code>v-on:</code> 开头，则说明该指令是事件绑定，此时 <code>elseif</code> 语句块内的代码将会被执行，在 <code>elseif</code> 语句块内，首先将指令字符串中的 <code>@</code> 字符或 <code>v-on:</code> 字符串去掉，然后直接调用 <code>addHandler</code> 函数。</p><p>打开 <code>src/compiler/helpers.js</code> 文件并找到 <code>addHandler</code> 函数，如下是 <code>addHandler</code> 函数签名：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addHandler</span> <span class="token punctuation">(</span>
  el<span class="token punctuation">:</span> ASTElement<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  modifiers<span class="token punctuation">:</span> <span class="token operator">?</span>ASTModifiers<span class="token punctuation">,</span>
  important<span class="token operator">?</span><span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
  warn<span class="token operator">?</span><span class="token punctuation">:</span> Function
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>可以看到 <code>addHandler</code> 函数接收六个参数，分别是：</p><ul><li><code>el</code>：当前元素描述对象</li><li><code>name</code>： 绑定属性的名字，即事件名称</li><li><code>value</code>：绑定属性的值，这个值有可能是事件回调函数名字，有可能是内联语句，有可能是函数表达式</li><li><code>modifiers</code>：指令对象</li><li><code>important</code>：可选参数，是一个布尔值，代表着添加的事件侦听函数的重要级别，如果为 <code>true</code>，则该侦听函数会被添加到该事件侦听函数数组的头部，否则会将其添加到尾部，</li><li><code>warn</code>：打印警告信息的函数，是一个可选参数</li></ul><p>了解 <code>addHandler</code> 函数所需的参数，我们再来看一下解析 <code>v-on</code> 指令时调用 <code>addHandler</code> 函数所传递的参数，如下高亮代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>onRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token function">addHandler</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> warn<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮代码中在调用 <code>addHandler</code> 函数时传递了全部六个参数。这里就不一一介绍这六个实参了，相信大家都知道这六个实参是什么。我们开始研究 <code>addHandler</code> 函数的实现，在 <code>addHandler</code> 函数的开头是这样一段代码：</p><pre class="language-js"><code>modifiers <span class="token operator">=</span> modifiers <span class="token operator">||</span> emptyObject
<span class="token comment">// warn prevent and passive modifier</span>
<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>
  process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> warn <span class="token operator">&amp;&amp;</span>
  modifiers<span class="token punctuation">.</span>prevent <span class="token operator">&amp;&amp;</span> modifiers<span class="token punctuation">.</span>passive
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token string">'passive and prevent can\'t be used together. '</span> <span class="token operator">+</span>
    <span class="token string">'Passive handler can\'t prevent default event.'</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>首先检测 <code>v-on</code> 指令的修饰符对象 <code>modifiers</code> 是否存在，如果在使用 <code>v-on</code> 指令时没有指定任何修饰符，则 <code>modifiers</code> 的值为 <code>undefined</code>，此时会使用冻结的空对象 <code>emptyObject</code> 作为代替。接着是一个 <code>if</code> 条件语句块，如果该 <code>if</code> 语句的判断条件成立，则说明开发者同时使用了 <code>prevent</code> 修饰符和 <code>passive</code> 修饰符，此时如果是在非生产环境下并且 <code>addHandler</code> 函数的第六个参数 <code>warn</code> 存在，则使用 <code>warn</code> 函数打印警告信息，提示开发者 <code>passive</code> 修饰符不能和 <code>prevent</code> 修饰符一起使用，这是因为在事件监听中 <code>passive</code> 选项参数就是用来告诉浏览器该事件监听函数是不会阻止默认行为的。</p><p>在往下是这样一段代码：</p><pre class="language-js"><code><span class="token comment">// check capture modifier</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>capture<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> modifiers<span class="token punctuation">.</span>capture
  name <span class="token operator">=</span> <span class="token string">'!'</span> <span class="token operator">+</span> name <span class="token comment">// mark the event as captured</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>once<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> modifiers<span class="token punctuation">.</span>once
  name <span class="token operator">=</span> <span class="token string">'~'</span> <span class="token operator">+</span> name <span class="token comment">// mark the event as once</span>
<span class="token punctuation">}</span>
<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>passive<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> modifiers<span class="token punctuation">.</span>passive
  name <span class="token operator">=</span> <span class="token string">'&amp;'</span> <span class="token operator">+</span> name <span class="token comment">// mark the event as passive</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码由三个 <code>if</code> 条件语句块组成，如果事件指令中使用了 <code>capture</code> 修饰符，则第一个 <code>if</code> 语句块的内容将被卑职，可以到在第一个 <code>if</code> 语句块内首先将 <code>modifiers.capture</code> 选项移除，紧接着在原始事件名称之前添加一个字符 <code>!</code>。假设我们事件绑定代码如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click.capture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上代码中点击事件使用了 <code>capture</code> 修饰符，所以在 <code>addHandler</code> 函数内部，会把事件名称 <code>'click'</code> 修改为 <code>'!click'</code>。</p><p>与第一个 <code>if</code> 语句块类似，第二个和第三个 <code>if</code> 语句块分别用来处理当事件使用了 <code>once</code> 修饰符和 <code>passive</code> 修饰符的情况。可以看到如果事件使用了 <code>once</code> 修饰符，则会在事件名称的前面添加字符 <code>~</code>，如果事件使用了 <code>passive</code> 修饰符，则会在事件名称前面添加字符 <code>&amp;</code>。也就是说如下两端代码是等价的：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click.once</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>等价于：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@~click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>再往下是如下这段代码：</p><pre class="language-js"><code><span class="token comment">// normalize click.right and click.middle since they don't actually fire</span>
<span class="token comment">// this is technically browser-specific, but at least for now browsers are</span>
<span class="token comment">// the only target envs that have right/middle clicks.</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> <span class="token string">'click'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">'contextmenu'</span>
    <span class="token keyword">delete</span> modifiers<span class="token punctuation">.</span>right
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>middle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">'mouseup'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这段代码用来规范化“右击”事件和点击鼠标中间按钮的事件，我们知道在浏览器中点击右键一般会出来一个菜单，这本质上是触发了 <code>contextmenu</code> 事件。而 <code>Vue</code> 中定义“右击”事件的方式是为 <code>click</code> 事件添加 <code>right</code> 修饰符。所以如上代码中首先检查了事件名称是否是 <code>click</code>，如果事件名称是 <code>click</code> 并且使用了 <code>right</code> 修饰符，则会将事件名称重写为 <code>contextmenu</code>，同时使用 <code>delete</code> 操作符删除 <code>modifiers.right</code> 属性。类似的在 <code>Vue</code> 中定义点击滚轮事件的方式是为 <code>click</code> 事件指定 <code>middle</code> 修饰符，但我们知道鼠标本没有滚轮点击事件，一般我们区分用户点击的按钮是不是滚轮的方式是监听 <code>mouseup</code> 事件，然后通过事件对象的 <code>event.button</code> 属性值来判断，如果 <code>event.button === 1</code> 则说明用户点击的是滚轮按钮。</p><p>不过这里有一点需要提醒大家，我们知道如果 <code>click</code> 事件使用了 <code>once</code> 修饰符，则事件的名字会被修改为 <code>~click</code>，所以当程序执行到如上这段时，事件名字是永远不会等于字符串 <code>'click'</code> 的，换句话说，如果同时使用 <code>once</code> 修饰符和 <code>right</code> 修饰符，则右击事件不会被触发，如下代码所示：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click.right.once</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClickRightOnce<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上代码无效，作为变通方案我们可以直接监听 <code>contextmenu</code> 事件，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@contextmenu.once</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClickRightOnce<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>但其实从源码角度也是很好解决的，只需要把范化“右击”事件和点击鼠标中间按钮的事件的这段代码提前即可，关于这一点我提交了一个 <a href="https://github.com/vuejs/vue/pull/8492" target="_blank" rel="noopener noreferrer">PR</a>，但实际上我认为还有更好的解决方案，那就是从 <code>mouseup</code> 事件入手，将 <code>contextmenu</code> 事件与“右击”事件完全分离处理，这里就不展开讨论了。</p><p>我们回到 <code>addHandler</code> 函数继续看后面的代码，接下来我们要看的是如下这段代码：</p><pre class="language-js"><code><span class="token keyword">let</span> events
<span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers<span class="token punctuation">.</span>native<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> modifiers<span class="token punctuation">.</span>native
  events <span class="token operator">=</span> el<span class="token punctuation">.</span>nativeEvents <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>nativeEvents <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  events <span class="token operator">=</span> el<span class="token punctuation">.</span>events <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>定义了 <code>events</code> 变量，然后判断是否存在 <code>native</code> 修饰符，如果 <code>native</code> 修饰符存在则会在元素描述对象上添加 <code>el.nativeEvents</code> 属性，初始值为一个空对象，并且 <code>events</code> 变量与 <code>el.nativeEvents</code> 属性具有相同的引用，另外大家注意如上代码中使用 <code>delete</code> 操作符删除了 <code>modifiers.native</code> 属性，到目前为止我们在讲解 <code>addHandler</code> 函数时以及遇到了很多次使用 <code>delete</code> 操作符删除修饰符对象属性的做法，那这么做的目的是什么呢？这是因为在代码生成阶段会使用 <code>for...in</code> 语句遍历修饰符对象，然后做一些相关的事情，所以在生成 <code>AST</code> 阶段把那些不希望被遍历的属性删除掉，更具体的内容我们会在代码生成中为大家详细讲解。回过头来，如果 <code>native</code> 属性不存在则会在元素描述对象上添加 <code>el.events</code> 属性，它的初始值也是一个空对象，此时 <code>events</code> 变量的引用将于 <code>el.events</code> 属性相同。</p><p>再往下是这样一段代码：</p><pre class="language-js"><code><span class="token keyword">const</span> newHandler<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>modifiers <span class="token operator">!==</span> emptyObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  newHandler<span class="token punctuation">.</span>modifiers <span class="token operator">=</span> modifiers
<span class="token punctuation">}</span>
</code></pre><p>定义了 <code>newHandler</code> 对象，该对象初始拥有一个 <code>value</code> 属性，该属性的值就是 <code>v-on</code> 指令的属性值。接着是一个 <code>if</code> 条件语句，该 <code>if</code> 语句的判断条件检测了修饰符对象 <code>modifiers</code> 是否不等于 <code>emptyObject</code>，我们知道当一个事件没有使用任何修饰符时，修饰符对象 <code>modifiers</code> 会被初始化为 <code>emptyObject</code>，所以如果修饰符对象 <code>modifiers</code> 不等于 <code>emptyObject</code> 则说明事件使用了修饰符，此时会把修饰符对象赋值给 <code>newHandler.modifiers</code> 属性。</p><p>再往下是 <code>addHandler</code> 函数的最后一段代码：</p><pre class="language-js"><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> events<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>handlers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  important <span class="token operator">?</span> handlers<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>newHandler<span class="token punctuation">)</span> <span class="token punctuation">:</span> handlers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> important <span class="token operator">?</span> <span class="token punctuation">[</span>newHandler<span class="token punctuation">,</span> handlers<span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span>handlers<span class="token punctuation">,</span> newHandler<span class="token punctuation">]</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> newHandler
<span class="token punctuation">}</span>

el<span class="token punctuation">.</span>plain <span class="token operator">=</span> <span class="token boolean">false</span>
</code></pre><p>首先定义了 <code>handlers</code> 常量，它的值是通过事件名称获取 <code>events</code> 对象下的对应的属性值得到的：<code>events[name]</code>，我们知道变量 <code>events</code> 要么是元素描述对象的 <code>el.nativeEvents</code> 属性的引用，要么就是元素描述对象 <code>el.events</code> 属性的引用。无论是谁的引用，在初始情况下 <code>events</code> 变量都是一个空对象，所以在第一次调用 <code>addHandler</code> 时 <code>handlers</code> 常量是 <code>undefined</code>，这件会导致接下来的代码中 <code>else</code> 语句块将被执行：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>handlers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> newHandler</span><span class="token punctuation">}</span>
</code></pre><p>可以看到在 <code>else</code> 语句块内，为 <code>events</code> 对象定义了与事件名称相同的属性，并以 <code>newHandler</code> 对象作为属性值。举个例子，假设我们有如下模板代码：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click.once</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上模板中监听了 <code>click</code> 事件，并绑定了名字叫做 <code>handleClick</code> 的事件监听函数，所以此时 <code>newHandler</code> 对象应该是：</p><pre class="language-js"><code>newHandler <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> <span class="token string">'handleClick'</span><span class="token punctuation">,</span>
  modifiers<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 注意这里是空对象，因为 modifiers.once 修饰符被 delete 了</span>
<span class="token punctuation">}</span>
</code></pre><p>由因为使用了 <code>once</code> 修饰符，所以事件名称将变为字符串 <code>'~click'</code>，又因为在监听事件时没有使用 <code>native</code> 修饰符，所以 <code>events</code> 变量是元素描述对象的 <code>el.events</code> 属性的引用，所以调用 <code>addHandler</code> 函数的最终结果就是在元素描述对象的 <code>el.events</code> 对象中添加相应事件的处理结果：</p><pre class="language-js"><code>el<span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">'~click'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token string">'handleClick'</span><span class="token punctuation">,</span>
    modifiers<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>现在我们来修改一个之前的模板，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上模板所示，我们有两个 <code>click</code> 事件的侦听，其中一个 <code>click</code> 事件使用了 <code>prevent</code> 修饰符，而另外一个 <code>click</code> 事件则没有使用修饰符，所以这两个 <code>click</code> 事件是不同，但这两个事件的名称却是相同的，都是 <code>'click'</code>，所以这将导致调用两次 <code>addHandler</code> 函数添加两次名称相同的事件，但是由于第一次调用 <code>addHandler</code> 函数添加 <code>click</code> 事件之后元素描述对象的 <code>el.events</code> 对象已经存在一个 <code>click</code> 属性，如下：</p><pre class="language-js"><code>el<span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">{</span>
  click<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token string">'handleClick1'</span><span class="token punctuation">,</span>
    modifiers<span class="token punctuation">:</span> <span class="token punctuation">{</span> prevent<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>所以当第二次调用 <code>addHandler</code> 函数时，如下 <code>elseif</code> 语句块的代码将被执行：</p><pre class="language-js"><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> events<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>handlers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  important <span class="token operator">?</span> handlers<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>newHandler<span class="token punctuation">)</span> <span class="token punctuation">:</span> handlers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> important <span class="token operator">?</span> <span class="token punctuation">[</span>newHandler<span class="token punctuation">,</span> handlers<span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span>handlers<span class="token punctuation">,</span> newHandler<span class="token punctuation">]</span></span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> newHandler
<span class="token punctuation">}</span>
</code></pre><p>此时 <code>newHandler</code> 对象是第二个 <code>click</code> 事件侦听的信息对象，而 <code>handlers</code> 常量保存的则是第一次被添加的事件信息，我们看如上高亮的那句代码，这句代码检测了参数 <code>important</code> 的真假，根据 <code>important</code> 参数的不同，会重新为 <code>events[name]</code> 赋值。可以看到 <code>important</code> 参数的真假所影响的仅仅是被添加的 <code>handlers</code> 对象的顺序。最终元素描述对象的 <code>el.events.click</code> 属性将变成一个数组，这个数组保存着前后两次添加的 <code>click</code> 事件的信息对象，如下：</p><pre class="language-js"><code>el<span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">{</span>
  click<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token string">'handleClick1'</span><span class="token punctuation">,</span>
      modifiers<span class="token punctuation">:</span> <span class="token punctuation">{</span> prevent<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token string">'handleClick2'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>这还没完，我们再次尝试修改我们的模板：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click.self</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick3<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>我们在上一次修改的基础上添加了第三个 <code>click</code> 事件侦听，但是我们使用了 <code>self</code> 修饰符，所以这个 <code>click</code> 事件与前两个 <code>click</code> 事件也是不同的，此时如下 <code>if</code> 语句块的代码将被执行：</p><pre class="language-js"><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> events<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token comment">/* istanbul ignore if */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>handlers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="highlighted-line">  important <span class="token operator">?</span> handlers<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>newHandler<span class="token punctuation">)</span> <span class="token punctuation">:</span> handlers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newHandler<span class="token punctuation">)</span></span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> important <span class="token operator">?</span> <span class="token punctuation">[</span>newHandler<span class="token punctuation">,</span> handlers<span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span>handlers<span class="token punctuation">,</span> newHandler<span class="token punctuation">]</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  events<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> newHandler
<span class="token punctuation">}</span>
</code></pre><p>由于此时 <code>el.events.click</code> 属性已经是一个数组，所以如上 <code>if</code> 语句的判断条件成立。在 <code>if</code> 语句块内执行了一句代码，这句代码是一个三元运算符，其作用很简单，我们知道 <code>important</code> 所影响的就是事件作用的顺序，所以根据 <code>important</code> 参数的不同，会选择使用数组的 <code>unshift</code> 方法将新添加的事件信息对象放到数组的头部，或者选择数组的 <code>push</code> 方法将新添加的事件信息对象放到数组的尾部。这样无论你有多少个同名事件的监听，都不会落下任何一个监听函数的执行。</p><p>接着我们注意到 <code>addHandler</code> 函数的最后一句代码，如下：</p><pre class="language-js"><code>el<span class="token punctuation">.</span>plain <span class="token operator">=</span> <span class="token boolean">false</span>
</code></pre><p>如果一个标签存在事件侦听，无论如何都不会认为这个元素是“纯”的，所以这里直接将 <code>el.plain</code> 设置为 <code>false</code>。<code>el.plain</code> 属性会影响代码生成阶段，并间接导致程序的执行行为，我们后面会总结一个分关于 <code>el.plain</code> 的变更情况，让大家充分的理解。</p><p>以上就是对于 <code>addHandler</code> 函数的讲解，我们发现 <code>addHandler</code> 函数对于元素描述对象的影响主要是在元素描述对象上添加了 <code>el.events</code> 属性和 <code>el.nativeEvents</code> 属性。对于 <code>el.events</code> 属性和 <code>el.nativeEvents</code> 属性的结构我们前面已经讲解得很细了，这里不再做总结。</p><p>最后我们回到 <code>src/compiler/parser/index.js</code> 文件中的 <code>processAttrs</code> 函数中，如下高亮代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
<span class="highlighted-line">  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>onRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token function">addHandler</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> warn<span class="token punctuation">)</span></span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><p>现在大家应该知道对于使用 <code>v-on</code> 指令绑定的时间，在解析阶段都做了哪些处理了吧。另外我们注意一下如上代码中调用 <code>addHandler</code> 函数时传递的第五个参数为 <code>false</code>，它实际上就是 <code>addHandler</code> 函数中名字为 <code>important</code> 的参数，它影响的是新添加的时间信息对象的顺序，由于上面代码中传递的 <code>important</code> 参数为 <code>false</code>，所以使用 <code>v-on</code> 添加的事件侦听函数将按照添加的顺序被先后执行。</p><p>以上就是对于 <code>processAttrs</code> 函数中对于 <code>v-on</code> 指令的解析。</p><h3 id="解析其他指令"><a href="#解析其他指令" aria-hidden="true" class="header-anchor">#</a> 解析其他指令</h3><p>讲解完了对于 <code>v-on</code> 指令的解析，接下来我们进入如下这段代码：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
<span class="highlighted-line">  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>dirRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token comment">// parse arg</span></span><span class="highlighted-line">  <span class="token keyword">const</span> argMatch <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>argRE<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">const</span> arg <span class="token operator">=</span> argMatch <span class="token operator">&amp;&amp;</span> argMatch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="highlighted-line">  <span class="token function">addDirective</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> name <span class="token operator">===</span> <span class="token string">'model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    <span class="token function">checkForAliasModel</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span>
</code></pre><p>如上高亮代码所示，如果一个指令既不是 <code>v-bind</code> 也不是 <code>v-on</code>，则如上 <code>else</code> 语句块的代码将被执行。这段代码的作用是用来处理除 <code>v-bind</code> 和 <code>v-on</code> 指令之外的其他指令，但这些指令中不包含 <code>v-once</code> 指令，因为 <code>v-once</code> 指令已经在 <code>processOnce</code> 函数中被处理了，同样的 <code>v-if/v-else-if/v-else</code> 等指令也不会被如上这段代码处理，下面是一个表格，表格中列出了所有 <code>Vue</code> 内置提供的指令与已经处理过的指令和剩余为处理指令的对照表格：</p><table><thead><tr><th>Vue 内置提供的所有指令</th><th>是否已经被解析</th><th>解析函数</th></tr></thead><tbody><tr><td><code>v-if</code></td><td>是</td><td><code>processIf</code></td></tr><tr><td><code>v-else-if</code></td><td>是</td><td><code>processIf</code></td></tr><tr><td><code>v-else</code></td><td>是</td><td><code>processIf</code></td></tr><tr><td><code>v-for</code></td><td>是</td><td><code>processFor</code></td></tr><tr><td><code>v-on</code></td><td>是</td><td><code>processAttrs</code></td></tr><tr><td><code>v-bind</code></td><td>是</td><td><code>processAttrs</code></td></tr><tr><td><code>v-pre</code></td><td>是</td><td><code>processPre</code></td></tr><tr><td><code>v-once</code></td><td>是</td><td><code>processOnce</code></td></tr><tr><td><code>v-text</code></td><td>否</td><td>无</td></tr><tr><td><code>v-html</code></td><td>否</td><td>无</td></tr><tr><td><code>v-show</code></td><td>否</td><td>无</td></tr><tr><td><code>v-cloak</code></td><td>否</td><td>无</td></tr><tr><td><code>v-model</code></td><td>否</td><td>无</td></tr></tbody></table><p>通过如上表格可以看到到目前为止还有五个指令没有得到处理，分别是 <code>v-text</code>、<code>v-html</code>、<code>v-show</code>、<code>v-cloak</code> 以及 <code>v-model</code>，除了这五个 <code>Vue</code> 内置提供的指令之外，开发者还可以自定义指令，所以上面代码中 <code>else</code> 语句块内的代码就是用来处理剩余这五个内置指令和自定义指令的。</p><p>我们回到 <code>else</code> 语句块内的代码，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
<span class="highlighted-line">  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>dirRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token comment">// parse arg</span></span><span class="highlighted-line">  <span class="token keyword">const</span> argMatch <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>argRE<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">const</span> arg <span class="token operator">=</span> argMatch <span class="token operator">&amp;&amp;</span> argMatch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="highlighted-line">  <span class="token function">addDirective</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> name <span class="token operator">===</span> <span class="token string">'model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    <span class="token function">checkForAliasModel</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span>
</code></pre><p>在 <code>else</code> 语句块内，首先使用字符串的 <code>replace</code> 方法配合 <code>dirRE</code> 正则去掉属性名称中的 <code>'v-'</code> 或 <code>':'</code> 或 <code>'@'</code> 等字符，并重新赋值 <code>name</code> 变量，所以此时 <code>name</code> 变量应该只包含属性名字，假如我们在一个标签中使用 <code>v-show</code> 指令，则此时 <code>name</code> 变量的值为字符串 <code>'show'</code>。但是对于自定义指令，开发者很可能为该指令提供参数，假设我们有一个叫做 <code>v-custom</code> 的指令，并且我们在使用该指令时为其指定了参数：<code>v-custom:arg</code>，这时重新赋值后的 <code>name</code> 变量应该是字符串 <code>'custom:arg'</code>。可能大家会问：如果指令有修饰符那是不是 <code>name</code> 变量保存的字符串中也包含修饰符？不会的，大家别忘了在 <code>processAttrs</code> 函数中每解析一个指令时都优先使用 <code>parseModifiers</code> 函数将修饰符解析完毕了，并且修饰符相关的字符串已经被移除，所以如上代码中的 <code>name</code> 变量中将不会包含修饰符字符串。</p><p>重新赋值 <code>name</code> 变量之后，会执行如下这两句代码：</p><pre class="language-js"><code><span class="token keyword">const</span> argMatch <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>argRE<span class="token punctuation">)</span>
<span class="token keyword">const</span> arg <span class="token operator">=</span> argMatch <span class="token operator">&amp;&amp;</span> argMatch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><p>第一句代码使用 <code>argRE</code> 正则匹配变量 <code>name</code>，并将匹配结果保存在 <code>argMatch</code> 常量中，由于使用的是 <code>match</code> 方法，所以如果匹配成功则会返回一个结果数组，匹配失败则会得到 <code>null</code>。<code>argRE</code> 正则我们在上一章讲解过，它用来匹配指令字符串中的参数部分，并且拥有一个捕获组用来捕获参数字符串，假设现在 <code>name</code> 变量的值为 <code>custom:arg</code>，是最终 <code>argMatch</code> 常量将是一个数组：</p><pre class="language-js"><code><span class="token keyword">const</span> argMatch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">':arg'</span><span class="token punctuation">,</span> <span class="token string">'arg'</span><span class="token punctuation">]</span>
</code></pre><p>可以看到 <code>argMatch</code> 数组中索引为 <code>1</code> 的元素保存着参数字符串。有了 <code>argMatch</code> 数组后将会执行第二句代码，第二句代码首先检测了 <code>argMatch</code> 是否存在，如果存在则取 <code>argMatch</code> 数组中索引为 <code>1</code> 的元素作为常量 <code>arg</code> 的值，所以常量 <code>arg</code> 所保存的就是参数字符串。</p><p>再我往下是一个 <code>if</code> 条件语句，如下：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>这个 <code>if</code> 语句检测了参数字符串 <code>arg</code> 是否存在，如果存在说明有参数传递给该指令，此时会执行 <code>if</code> 语句块内的代码。可以发现 <code>if</code> 语句块内的这句代码的作用就是用来将参数字符串从 <code>name</code> 字符串中移除掉的，由于参数字符串 <code>arg</code> 不包含冒号(<code>:</code>)字符，所以需要使用 <code>-(arg.length + 1)</code> 才能正确截取。举个例子，假设此时 <code>name</code> 字符串为 <code>'custom:arg'</code>，再经过如上代码处理之后，最终 <code>name</code> 字符串将变为 <code>'custom'</code>，可以看到此时的 <code>name</code> 变量已经变成了真正的指令名字了。</p><p>再往下，将执行如下这句代码：</p><pre class="language-js"><code><span class="token function">addDirective</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span>
</code></pre><p>这句代码调用了 <code>addDirective</code> 函数，并传递给该函数六个参数，为了让大家有直观的感受，我们还是举个例子，假设我们的指令为：<code>v-custom:arg.modif=&quot;myMethod&quot;</code>，则最终调用 <code>addDirective</code> 函数时所传递的参数如下：</p><pre class="language-js"><code><span class="token function">addDirective</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token string">'custom'</span><span class="token punctuation">,</span> <span class="token string">'v-custom:arg.modif'</span><span class="token punctuation">,</span> <span class="token string">'myMethod'</span><span class="token punctuation">,</span> <span class="token string">'arg'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> modif<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>实际上 <code>addDirective</code> 函数与 <code>addHandler</code> 函数类似，只不过 <code>addDirective</code> 函数的作用是用来在元素描述对象上添加 <code>el.directives</code> 属性的，如下是 <code>addDirective</code> 函数的源码，它来自 <code>src/compiler/helpers.js</code> 文件：</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addDirective</span> <span class="token punctuation">(</span>
  el<span class="token punctuation">:</span> ASTElement<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  rawName<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  arg<span class="token punctuation">:</span> <span class="token operator">?</span>string<span class="token punctuation">,</span>
  modifiers<span class="token punctuation">:</span> <span class="token operator">?</span>ASTModifiers
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>el<span class="token punctuation">.</span>directives <span class="token operator">||</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>directives <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> modifiers <span class="token punctuation">}</span><span class="token punctuation">)</span>
  el<span class="token punctuation">.</span>plain <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre><p>可以看到 <code>addDirective</code> 函数接收六个参数，在 <code>addDirective</code> 函数体内，首先判断了元素描述对象的 <code>el.directives</code> 是否存在，如果不存在则先将其初始化一个空数组，然后在使用 <code>push</code> 方法添加一个指令信息对象到 <code>el.directives</code> 数组中，如果 <code>el.directives</code> 属性已经存在，则直接使用 <code>push</code> 方法将指令信息对象添加到 <code>el.directives</code> 数组中。我们一直说的<strong>指令信息对象</strong>实际上指的就是如上代码中传递给 <code>push</code> 方法的参数：</p><pre class="language-js"><code><span class="token punctuation">{</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> modifiers <span class="token punctuation">}</span>
</code></pre><p>另外我们注意到在 <code>addDirective</code> 函数的最后，与 <code>addHandler</code> 函数类似，也有一句将元素描述对象的 <code>el.plain</code> 属性设置为 <code>false</code> 的代码。</p><p>我们回到 <code>processAttrs</code> 函数中，继续看代码，如下高亮的代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bindRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-bind</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// v-on</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// normal directives</span>
  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>dirRE<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token comment">// parse arg</span>
  <span class="token keyword">const</span> argMatch <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>argRE<span class="token punctuation">)</span>
  <span class="token keyword">const</span> arg <span class="token operator">=</span> argMatch <span class="token operator">&amp;&amp;</span> argMatch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">addDirective</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span>
<span class="highlighted-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> name <span class="token operator">===</span> <span class="token string">'model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    <span class="token function">checkForAliasModel</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span></span><span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span>
</code></pre><p>这段高亮的代码是 <code>else</code> 语句块的最后一段代码，它是一个 <code>if</code> 条件语句块，在非生产环境下，如果指令的名字为 <code>model</code>，则会调用 <code>checkForAliasModel</code> 函数，并将元素描述对象和 <code>v-model</code> 属性值作为参数传递，这段代码的作用是什么呢？我们找到 <code>checkForAliasModel</code> 函数，如下：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkForAliasModel</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _el <span class="token operator">=</span> el
  <span class="token keyword">while</span> <span class="token punctuation">(</span>_el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_el<span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token operator">&amp;&amp;</span> _el<span class="token punctuation">.</span>alias <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`&lt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>el<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> v-model=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;&gt;: `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`You are binding v-model directly to a v-for iteration alias. `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`This will not be able to modify the v-for source array because `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`writing to the alias is like modifying a function local variable. `</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token string">`Consider using an array of objects and use v-model on an object property instead.`</span></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    _el <span class="token operator">=</span> _el<span class="token punctuation">.</span>parent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p><code>checkForAliasModel</code> 函数的作用就是以使用了 <code>v-model</code> 指令的标签开始，逐层向上遍历父级标签的元素描述对象，知道根元素为止。并且在遍历的过程中一旦发现这些标签的元素描述对象中存在满足条件：<code>_el.for &amp;&amp; _el.alias === value</code> 的情况，则会打印警告信息。我们先来看如下条件：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>_el<span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token operator">&amp;&amp;</span> _el<span class="token punctuation">.</span>alias <span class="token operator">===</span> value<span class="token punctuation">)</span>
</code></pre><p>如果这个条件成立，则说明使用了 <code>v-model</code> 指令的标签或其父代标签使用了 <code>v-for</code> 指令，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>item of list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>假设如上代码中的 <code>list</code> 数组如下：</p><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code></pre><p>此时将会渲染三个输入框，但是当我们修改输入框的值时，这个变更是不会提现到 <code>list</code> 数组的，换句话说如上代码中的 <code>v-model</code> 指令无效，为什么无效呢？这与 <code>v-for</code> 指令的实现有关，如上代码中的 <code>v-model</code> 指令所执行的修改操作等价于修改了函数的局部变量，这当然不会影响到真正的数据。为了解决这个问题，<code>Vue</code> 也给了我们一个方案，那就是使用对象数组替代基本类型值的数组，并在 <code>v-model</code> 指令中绑定对象的属性，我们修改一下上例并使其生效：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>obj of list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>obj.item<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>此时在定义 <code>list</code> 数组时，应该将其定义为：</p><pre class="language-js"><code><span class="token punctuation">[</span>
  <span class="token punctuation">{</span> item<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> item<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> item<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre><p>所以实际上 <code>checkForAliasModel</code> 函数的作用就是给开发者合适的提醒。</p><p>以上就是对自定义指令和剩余的五个未被解析的内置指令的处理，可以看到每当遇到一个这样的指令，都会在元素描述对象的 <code>el.directives</code> 数组中添加一个指令信息对象，如下：</p><pre class="language-js"><code>el<span class="token punctuation">.</span>directives <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    name<span class="token punctuation">,</span> <span class="token comment">// 指令名字</span>
    rawName<span class="token punctuation">,</span> <span class="token comment">// 指令原始名字</span>
    value<span class="token punctuation">,</span> <span class="token comment">// 指令的属性值</span>
    arg<span class="token punctuation">,</span> <span class="token comment">// 指令的参数</span>
    modifiers <span class="token comment">// 指令的修饰符</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre><p>注意，如上注释中我们把指令信息对象中的 <code>value</code> 属性说成“指令的属性值”，我已经不止一次的强调过，在解析编译阶段一切都是字符串，并不是 <code>Vue</code> 中数据状态的值，大家千万不要搞混。</p><h3 id="处理非指令属性"><a href="#处理非指令属性" aria-hidden="true" class="header-anchor">#</a> 处理非指令属性</h3><p>上一节中我们讲解了 <code>processAttrs</code> 函数对于指令的处理，接下来我们将讲解 <code>processAttrs</code> 函数对于那些非指令的属性是如何处理的，如下代码所示：</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">processAttrs</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> el<span class="token punctuation">.</span>attrsList
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> l<span class="token punctuation">,</span> name<span class="token punctuation">,</span> rawName<span class="token punctuation">,</span> value<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> isProp
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> rawName <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name
    value <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>value
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 省略...</span>
<span class="highlighted-line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span><span class="highlighted-line">      <span class="token comment">// 省略...</span></span><span class="highlighted-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如上高亮的代码所示，这个 <code>else</code> 语句块内代码的作用就是用来处理非指令属性的，如下列出的非指令属性是我们在之前的讲解中已经讲过的指令：</p><ul><li><code>key</code></li><li><code>ref</code></li><li><code>slot</code>、<code>slot-scope</code>、<code>scope</code>、<code>name</code></li><li><code>is</code>、<code>inline-template</code></li></ul><p>这些非指令属性都已经被相应的处理函数解析过了，所以 <code>processAttrs</code> 函数是不负责处理如上这些非指令属性的。换句话说除了以上属性基本指令的非指令属性基本都由 <code>processAttrs</code> 函数来处理，比如 <code>id</code>、<code>width</code> 等，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>box<span class="token punctuation">&quot;</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>100px<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>如上 <code>div</code> 标签中的 <code>id</code> 属性和 <code>width</code> 属性都会被 <code>processAttrs</code> 函数处理，可能大家会问 <code>class</code> 属性是不是也被 <code>processAttrs</code> 函数处理呢？不是的，大家别忘了在 <code>processElement</code> 函数中有这样一段代码：</p><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> transforms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element <span class="token operator">=</span> transforms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token operator">||</span> element
<span class="token punctuation">}</span>
</code></pre><p>这段代码在 <code>processAttrs</code> 函数之前执行，并且这段代码的作用是调用“中置处理”钩子，而 <code>class</code> 属性和 <code>style</code> 属性都会在中置处理钩子中被处理，而并非 <code>processAttrs</code> 函数。</p><p>接下来我们就查看一下这段用来处理非指令属性的代码，如下 <code>else</code> 语句块内的代码所示：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>dirRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// literal attribute</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">parseText</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> delimiters<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;: `</span></span> <span class="token operator">+</span>
        <span class="token string">'Interpolation inside attributes has been removed. '</span> <span class="token operator">+</span>
        <span class="token string">'Use v-bind or the colon shorthand instead. For example, '</span> <span class="token operator">+</span>
        <span class="token string">'instead of &lt;div id=&quot;{{ val }}&quot;&gt;, use &lt;div :id=&quot;val&quot;&gt;.'</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">addAttr</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token comment">// #6887 firefox doesn't update muted state if set via attribute</span>
  <span class="token comment">// even immediately after element creation</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">.</span>component <span class="token operator">&amp;&amp;</span>
      name <span class="token operator">===</span> <span class="token string">'muted'</span> <span class="token operator">&amp;&amp;</span>
      <span class="token function">platformMustUseProp</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> el<span class="token punctuation">.</span>attrsMap<span class="token punctuation">.</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">addProp</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>如上 <code>else</code> 语句块内的代码中，首先执行的是如下这段代码，它是一个 <code>if</code> 条件语句块：</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">parseText</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> delimiters<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;: `</span></span> <span class="token operator">+</span>
      <span class="token string">'Interpolation inside attributes has been removed. '</span> <span class="token operator">+</span>
      <span class="token string">'Use v-bind or the colon shorthand instead. For example, '</span> <span class="token operator">+</span>
      <span class="token string">'instead of &lt;div id=&quot;{{ val }}&quot;&gt;, use &lt;div :id=&quot;val&quot;&gt;.'</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>可以看到，在非生产环境下才会执行该 <code>if</code> 语句块内的代码，在改 <code>if</code> 语句块内首先调用了 <code>parseText</code> 函数，这个函数来自于 <code>src/compiler/parser/text-parser.js</code> 文件，<code>parseText</code> 函数的作用是用来解析字面量表达式的，什么是字面量表达式呢？如下模板代码所示：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>{{ isTrue ? <span class="token punctuation">'</span>a<span class="token punctuation">'</span> : <span class="token punctuation">'</span>b<span class="token punctuation">'</span> }}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>其中字符串 <code>&quot;b&quot;</code> 就称为字面量表达式，此时就会使用 <code>parseText</code> 函数来解析这段字符串。至于 <code>parseText</code> 函数是如何对这段字符串进行解析的，我们会在后面讲解处理文本节点时再来详细说明。这里大家只需要执行，如果使用 <code>parseText</code> 函数能够成功解析某个非指令属性的属性值字符串，则说明该非指令属性的属性值使用了字面量表达式，就如同上面的模板中的 <code>id</code> 属性一样。此时将会打印警告信息，提示开发者使用绑定属性作为替代，如下：</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>isTrue ? <span class="token punctuation">'</span>a<span class="token punctuation">'</span> : <span class="token punctuation">'</span>b<span class="token punctuation">'</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>这就是上面那段 <code>if</code> 语句块代码的作用，我们往下继续看代码，接下来将执行如下这句代码：</p><pre class="language-js"><code><span class="token function">addAttr</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>可以看到，对于任何非指令属性，都会使用 <code>addAttr</code> 函数将该属性与该属性对应的字符串值添加到元素描述对象的 <code>el.attrs</code> 数组中。这里大家需要注意的是，如上这句代码中使用 <code>JSON.stringify</code> 函数对属性值做了处理，这么做的目的相信大家都知道了，就是让该属性的值当做一个纯字符串对待。</p><p>理论上代码运行到这里就已经足够了，该做的事情都已经完成了，但是我们发现在 <code>else</code> 语句块的最后，还有如下这样一段代码：</p><pre class="language-js"><code><span class="token comment">// #6887 firefox doesn't update muted state if set via attribute</span>
<span class="token comment">// even immediately after element creation</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">.</span>component <span class="token operator">&amp;&amp;</span>
    name <span class="token operator">===</span> <span class="token string">'muted'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token function">platformMustUseProp</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> el<span class="token punctuation">.</span>attrsMap<span class="token punctuation">.</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">addProp</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>实际上元素描述对象的 <code>el.attrs</code> 数组中所存储的任何属性都会在由虚拟DOM创建真实DOM的过程中使用 <code>setAttribute</code> 方法将属性添加到真实DOM元素上，而在火狐浏览器中存在无法通过DOM元素的 <code>setAttribute</code> 方法为 <code>video</code> 标签添加 <code>muted</code> 属性的问题，所以如上代码就是为了解决该问题的，其方案是如果一个属性的名字是 <code>muted</code> 并且该标签满足 <a href="/vue-design/appendix/web-util.html#mustuseprop">platformMustUseProp</a> 函数(<code>video</code> 标签满足)，则会额外调用 <code>addProp</code> 函数将属性添加到元素描述对象的 <code>el.props</code> 数组中。为什么这么做呢？这是因为元素描述对象的 <code>el.props</code> 数组中所存储的任何属性都会在由虚拟DOM创建真实DOM的过程中直接使用真实DOM对象添加，也就是说对于 <code>&lt;video&gt;</code> 标签的 <code>muted</code> 属性的添加方式为：<code>videoEl.muted = true</code>。另外如上代码的注释中已经提供了相应的 <code>issue</code> 号：<code>#6887</code>，感兴趣的同学可以去看一下。</p><h2 id="文本节点的元素描述对象"><a href="#文本节点的元素描述对象" aria-hidden="true" class="header-anchor">#</a> 文本节点的元素描述对象</h2><h2 id="parsetext-函数解析字面量表达式"><a href="#parsetext-函数解析字面量表达式" aria-hidden="true" class="header-anchor">#</a> parseText 函数解析字面量表达式</h2><h2 id="对结束标签的处理"><a href="#对结束标签的处理" aria-hidden="true" class="header-anchor">#</a> 对结束标签的处理</h2><h2 id="注释节点的元素描述对象"><a href="#注释节点的元素描述对象" aria-hidden="true" class="header-anchor">#</a> 注释节点的元素描述对象</h2><h2 id="对元素描述对象的总结"><a href="#对元素描述对象的总结" aria-hidden="true" class="header-anchor">#</a> 对元素描述对象的总结</h2></div><div class="content edit-link"><a href="https://github.com/HcySunYang/vue-design/edit/master/docs/art/83vue-parsing-2.md" target="_blank" rel="noopener noreferrer">错别字纠正</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/vue-design/art/82vue-parsing.html" class="prev">
          句法分析 - 生成真正的AST(一)
        </a></span><span class="next"><a href="/vue-design/art/84vue-codegen.html">
          编译器之代码的生成
        </a> →
      </span></p></div></div></div></div>
    <script src="/vue-design/assets/js/10.a388adda.js" defer></script><script src="/vue-design/assets/js/app.b12bc3e2.js" defer></script>
  </body>
</html>
